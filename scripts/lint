#!/usr/bin/env bash
# NAME
#     lint - run the repository linters and policy checks
# SYNOPSIS
#     scripts/lint [-h|--help]
# DESCRIPTION
#     Executes ruff, sqlfluff, and biome lint passes with repository settings,
#     plus a custom verifier that rejects long inline SQL strings. Prints terse
#     [OK]/[FAIL] summaries and points to temp logs on failures.

set -euo pipefail

readonly REPO_NAME="dojo"
readonly SCRIPT_NAME="lint"
readonly TMP_DIR="${TMPDIR:-/tmp}"
RUN_DIR=$(mktemp -d "${TMP_DIR}/${REPO_NAME}-${SCRIPT_NAME}-XXXXXX")
readonly RUN_DIR
had_failure=0

usage() {
    cat <<EOF
NAME
    ${SCRIPT_NAME} - run the repository linters with strict settings
SYNOPSIS
    scripts/${SCRIPT_NAME} [-h|--help]
DESCRIPTION
    Runs ruff, sqlfluff, biome, and a custom SQL-string verifier. Each step emits
    a terse [OK]/[FAIL] summary and references a temp log when it fails.
EOF
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage
                exit 1
                ;;
        esac
    done
}

sanitize_label() {
    local label="$1"
    local sanitized
    sanitized=$(printf '%s' "$label" | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-')
    sanitized="${sanitized//--/-}"
    sanitized="${sanitized#-}"
    sanitized="${sanitized%-}"
    if [[ -z "$sanitized" ]]; then
        sanitized="tool"
    fi
    printf '%s' "$sanitized"
}

time_diff() {
    python - "$1" "$2" <<'PY'
import sys
start = float(sys.argv[1])
end = float(sys.argv[2])
print(f"{end - start:.2f}")
PY
}

log_stats() {
    local file="$1"
    local lines bytes
    lines=$(wc -l <"$file" | tr -d '[:space:]')
    bytes=$(stat -c%s "$file")
    printf '%s %s' "$lines" "$bytes"
}

run_tool() {
    local label="$1"
    shift
    local suite_id
    suite_id=$(sanitize_label "$label")
    local log
    log="${RUN_DIR}/${suite_id}.log"
    local start end elapsed
    start=$(date +%s.%N)

    if "$@" >"$log" 2>&1; then
        end=$(date +%s.%N)
        elapsed=$(time_diff "$start" "$end")
        rm -f "$log"
        echo "[OK]   $label in ${elapsed}s"
    else
        end=$(date +%s.%N)
        elapsed=$(time_diff "$start" "$end")
        local stats lines bytes log_name
        stats=$(log_stats "$log")
        lines=${stats%% *}
        bytes=${stats##* }
        log_name=$(basename "$log")
        echo "[FAIL] $label failed in ${elapsed}s see ${log_name}{lines: ${lines}, bytes: ${bytes}}"
        had_failure=1
    fi
}

run_sql_string_guard() {
    run_tool "py-sql check" python - "src/dojo" <<'PY'
import argparse
import ast
import os
import re

SQL_PATTERNS = [
    r"\bSELECT\b.+\bFROM\b",
    r"\bINSERT\b.+\bINTO\b",
    r"\bUPDATE\b.+\bSET\b",
    r"\bDELETE\b.+\bFROM\b",
    r"\bCREATE\b.+\b(TABLE|VIEW|INDEX)\b",
    r"\bALTER\b.+\bTABLE\b",
    r"\bDROP\b.+\b(TABLE|VIEW|INDEX)\b",
    r"\bWITH\b.+\bSELECT\b",
]


def is_sql_like(value: str) -> bool:
    cleaned = " ".join(value.split())
    return any(re.search(pattern, cleaned, re.IGNORECASE | re.DOTALL) for pattern in SQL_PATTERNS)


def find_docstring_nodes(tree: ast.AST) -> set[ast.Constant]:
    nodes: set[ast.Constant] = set()
    for node in ast.walk(tree):
        if isinstance(node, (ast.Module, ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
            if node.body and isinstance(node.body[0], ast.Expr) and isinstance(node.body[0].value, ast.Constant):
                expr = node.body[0]
                if isinstance(expr.value.value, str):
                    nodes.add(expr.value)
    return nodes


def scan_file(path: str, min_len: int, bucket: list[str]) -> None:
    try:
        with open(path, "r", encoding="utf-8") as f:
            source = f.read()
    except Exception as exc:
        bucket.append(f"# Skipping {path}: {exc}")
        return

    try:
        tree = ast.parse(source, filename=path)
    except SyntaxError as exc:
        bucket.append(f"# Skipping {path}: {exc}")
        return

    docstrings = find_docstring_nodes(tree)
    for node in ast.walk(tree):
        if isinstance(node, ast.Constant) and isinstance(node.value, str):
            if node in docstrings:
                continue
            literal = node.value
            if len(literal) >= min_len and is_sql_like(literal):
                snippet = " ".join(literal.split())[:120]
                bucket.append(f"{path}:{node.lineno}:{len(literal)}: {snippet!r}")


def iter_python_paths(root: str):
    for dirpath, _, filenames in os.walk(root):
        for name in filenames:
            if name.endswith(".py"):
                yield os.path.join(dirpath, name)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Find long SQL-like string literals in Python files."
    )
    parser.add_argument("root", help="Root directory to scan")
    parser.add_argument(
        "-n",
        "--min-len",
        type=int,
        default=200,
        help="Minimum length to report (default: 200)",
    )
    args = parser.parse_args()

    violations: list[str] = []
    for path in iter_python_paths(args.root):
        scan_file(path, args.min_len, violations)

    if violations:
        print("Detected SQL-like string literals that belong in SQL files:")
        for violation in violations:
            print(violation)
        raise SystemExit(1)


if __name__ == "__main__":
    main()
PY
}

parse_args "$@"

run_tool "ruff" ruff check .
run_tool "sqlfluff" sqlfluff lint --dialect duckdb src/dojo/sql
run_tool "biome" biome lint src/dojo/frontend
run_tool "actionlint" actionlint
run_sql_string_guard

if [[ "$had_failure" -ne 0 ]]; then
    echo "[FAIL] ${SCRIPT_NAME} (one or more linters failed) log dir: ${RUN_DIR}"
    exit 1
fi

echo "[OK] ${SCRIPT_NAME} (all linters passed)"
exit 0
